### Концепция

__FlexBin__ (_Flexible Binary Format_) - гибкий бинарный формат хранения и передачи данных, спроектированный Мозулёвым Дмитрием как универсальный формат, обеспечивающий гибкость, компактность и высокую производительность передачи данных.

* [Терминология](#терминология)
* [Разновидности полей](#разновидности-полей)
* [Формат хранения объекта](#формат-хранения-объекта)
* [Формат хранения структуры](#формат-хранения-структуры)
* [Формат хранения поля](#формат-хранения-поля)
* [Типы полей](#типы-полей)
* [Формат кодирования строк (FlexString)](#формат-кодирования-строк-flexstring)
* [Сравнительное тестирование (общее)](#сравнительное-тестирование-общее)
* [Сравнительное тестирование (вложенные структуры)](#сравнительное-тестирование-вложенные-структуры)

### Терминология

* Поле - некая область памяти в структуре или объекте, о которой знает отправляющая и/или принимающая стороны.
* Структура - сгруппированный набор полей, располагающийся по значению («на стеке»).
* Объект - сгруппированный набор полей, память под который выделяется как правило в куче.
* Идентификатор поля - числовое значение (от 0 до 255), позволяющее однозначно идентифицировать поле в рамках объекта или структуры.
* Идентификатор класса - числовое значение (от 0 до 65535), позволяющее однозначно определить класс, объект которого, к примеру, можно создать для заполнения.
* Тип поля - разновидность представления значения поля в бинарном потоке.
* Упаковка поля - подбор оптимального типа поля и его запись, с целью минимизации его представления в памяти.
* Тип поля по умолчанию - наиболее компактный тип поля, гарантирующий идентичность его сериализации и десериализации, если не проводить его упаковку.

### Разновидности полей

Данный список введён для стандартизации подходов к сериализации и десериализации отдельно взятых полей:
* Обязательное (_required_) - поле, при отсутствии которого в потоке данных, должна вызываться
ошибка.
* Опциональное (_optional_) - поле, наличие которого не обязательно. При равенстве значению по умолчанию - в бинарный поток не пишется. При чтении заполняется значением по умолчанию если отсутствует в бинарном потоке.
* Упрощённое (_simplified_) - опциональное поле, которое не проходит проверку на значение по умолчанию и не упаковывается, а записывается всегда с типом поля по умолчанию. При чтении если отсутствует в бинарном потоке - заполняется нулями.
* Фиксированное (_fixed_) - обязательное поле, которое кодируется сырыми бинарными данными, без упоминания его идентификатора и типа. В качестве типа поля используется тип поля по умолчанию.

### Формат хранения объекта

Предполагается, что единицей обмена данными между различными системами является объект. Объекты могут содержать в себе разные данные, класс объектов тоже может быть разный. Кроме того, объекты могут содержать дочерние объекты, поэтому данные организованы таким образом, что кроме набора полей, хранятся так же идентификатор класса и размер. Размер важен как для проверок корректности пакета, так и для случаев, когда неизвестный класс в бинарном потоке необходимо пропустить.

| Имя          | Размер | Комментарий |
| :---:        | :---:  | :---        |
| Size         | 4      | Идентификатор класса. Зная этот идентификатор на принимающей стороне можно создать объект нужного класса. |
| ClassId      | 2      | Идентификатор класса. Зная этот идентификатор на принимающей стороне можно создать объект нужного класса. |
| Fixed fields | -      | Бинарные данные для фиксированных полей. Как правило отсутствуют. Размер и состав фиксированных полей **должен** однозначно совпадать как на принимающей, так и на отправляющей сторонах. |
| Fields       | -      | Данные для набора полей в стандартном формате. Поля перечисляются в порядке возрастания идентификатора! |
| End marker   | 1      | Маркер конца данных по объекту. |

### Формат хранения структуры

Структура, как и объект, хранит в себе набор полей. Ключевое отличие состоит в том, что состав структуры известен на момент объявления, что даёт возможность упростить процесс сериализации и десериализации, а так же сэкономить место в бинарном потоке. Не смотря на тот факт, что структуры принято хранить по значению («на стеке»), на практике организация памяти может быть реализована любым удобным образом.

| Имя          | Размер | Комментарий |
| :---:        | :---:  | :---        |
| Fixed fields | -      | Бинарные данные для фиксированных полей. Как правило отсутствуют. Размер и состав фиксированных полей **должен** однозначно совпадать как на принимающей, так и на отправляющей сторонах. |
| Fields       | -      | Данные для набора полей в стандартном формате. Поля перечисляются в порядке возрастания идентификатора! |
| End marker   | 1      | Маркер конца данных по структуре. |

### Формат хранения поля

| Имя          | Размер | Комментарий |
| :---:        | :---:  | :---        |
| Type         | 1      | Тип поля. Определяет представление и размер данных. |
| Id           | 1      | Идентификатор поля. |
| ---          | ---    | _Данные_ |

### Типы полей

| Тип   | Имя         | Размер | Комментарий |
| :---: | :---:       | :---:  | :---        |
| 0     | 0 (false)   | 0      | Числовое значение 0. |
| 1     | 1 (true)    | 0      | Числовое значение 1. |
| 2     | uint8       | 1      | Безнаковое целое. |
| 3     | int8        | 1      | Знаковое целое. |
| 4     | uint16      | 2      | Безнаковое целое. |
| 5     | int16       | 2      | Знаковое целое. |
| 6     | uint24      | 3      | Безнаковое целое. |
| 7     | int24       | 3      | Знаковое целое. |
| 8     | uint32      | 4      | Безнаковое целое. |
| 9     | int32       | 4      | Знаковое целое. |
| 10    | uint40      | 5      | Безнаковое целое. |
| 11    | int40       | 5      | Знаковое целое. |
| 12    | uint48      | 6      | Безнаковое целое. |
| 13    | int48       | 6      | Знаковое целое. |
| 14    | uint56      | 7      | Безнаковое целое. |
| 15    | int56       | 7      | Знаковое целое. |
| 16    | uint64      | 8      | Безнаковое целое. |
| 17    | int64       | 8      | Знаковое целое. |
| 18    | float       | 4      | Число с плавающей точкой единичной точности (IEEE 754-1985). |
| 19    | double      | 8      | Число с плавающей точкой двойной точности (IEEE 754-1985). |
| 20    | currency    | 8      | Денежный формат. Представляет из себя дробное число с фиксированной точкой - 4 знака. По сути это int64, которое конвертируется в double путём деления на 10000. |
| 21    | date        | 4      | Дата, количество дней с 1 января 1601 года. |
| 22    | time        | 4      | Время, количество 100-наносекундных интервалов в течение дня. |
| 23    | datetime    | 8      | Дата и время, количество 100-наносекундных интервалов с 1 января 1601 года (формат Windows FILETIME). |
| 24    | string      | 4+     | Строка в формате FlexString, где количество байт кодируется 4 байтами. |
| 25    | shortstring | 1+     | Короткая в формате FlexString, где количество байт кодируется 1 байтом. |
| 26    | bytes       | 4+     | Бинарный массив, где количество элементов кодируется 4 байтами. |
| 27    | shortbytes  | 1+     | Короткий бинарный массив, где количество элементов кодируется 1 байтом. |
| 28    | array       | 4+     | Массив произвольных значений, где количество элементов кодируется 4 байтами. Каждый элемент сериализуется по такому же принципу, что и поля, только без байта идентификатора, т.е. _тип поля_ и _данные_. |
| 29    | shortarray  | 1+     | Короткий массив произвольных значений, где количество элементов кодируется 1 байтом. Каждый элемент сериализуется по такому же принципу, что и поля, только без байта идентификатора, т.е. _тип поля_ и _данные_. |
| 30    | enumset     | 1+     | Множество (короткий массив) строковых идентификаторов (shortstring). |
| 31    | struct      | 0+     | Дочерняя структура. |
| 32    | object      | 2+     | Дочерний объект (содержит идентификатор класса). |
| 255   | end marker  | 0      | Маркер конца данных. |

### Формат кодирования строк (FlexString)

FlexString (Flexible String) - ASCII совместимый формат кодирования Unicode символов, обеспечивающий высокую скорость обработки и компактность представления в бинарном потоке. К примеру, для русско-английского текста, кодирование происходит по 1 байту на символ, причём английские будут читабельны в дампе результирующего потока.

![Тестирование алгоритма FlexString](data/FlexString.png)

ASCII символы, т.е. от 0 до 127 - кодируются как есть. Для остальных символов используется принцип "база + смещение". Значения от 128 до 254 содержат смещение (+ 128) относительно базы. База - это некая меняющаяся со временем величина, младшие 7 бит которой равны нулю. Значение базы по умолчанию 0x0400, именно поэтому русско-английские тексты получается закодировать 1 байтом на символ, т.к. большинство кириллических символов умещается в диапазоне 0x0400..0x047e, и каждый символ текста кодируется либо в ASCII, либо смещением относительно базы. Если в тексте встречается символ, выходящий за диапазон базы и ASCII, то он кодируется 3 байтами: 255 и Unicode символ. В этом случае база меняется путём обнуления младших 7 битов символа.

```pascal
function FlexStringEncode(const S: UnicodeString): RawByteString;
var
  i, Count: Integer;
  Src: PWord;
  Dest: PByte;
  Base, C: Word;
begin
  Count := Length(S);
  SetLength(Result, Count * 3);
  Src := Pointer(S);
  Dest := Pointer(Result);

  Base := $0400;
  for i := 1 to Count do
  begin
    C := Src^;

    if (C <= 127) then
    begin
      // ASCII символ
      Dest^ := C;
      Inc(Dest);
    end else
    if (C >= Base) and (C <= Base + 126) then
    begin
      // символ в базе
      Dest^ := 128 + (C - Base);
      Inc(Dest);
    end else
    begin
      // новый символ
      Dest^ := 255;
      Inc(Dest);
      PWord(Dest)^ := C;
      Inc(Dest, SizeOf(Word));
      Base := C and $FF80;
    end;

    Inc(Src);
  end;

  SetLength(Result, NativeUInt(Dest) - NativeUInt(Result));
end;

function FlexStringDecode(const S: RawByteString): UnicodeString;
var
  Count: Integer;
  Src: PByte;
  Dest: PWord;
  Base, C: Word;
begin
  Count := Length(S);
  SetLength(Result, Count);
  Src := Pointer(S);
  Dest := Pointer(Result);

  Base := $0400;
  while (Count <> 0) do
  begin
    C := Src^;

    case C of
      0..127:
      begin
        // ASCII символ
        Inc(Src);
      end;
      128..254:
      begin
        // символ в базе
        C := (C - 128) + Base;
        Inc(Src);
      end;
    else
      // 255:
      // новый символ
      Inc(Src);
      C := PWord(Src)^;
      Inc(Src, SizeOf(Word));
      Dec(Count, 2);
      Base := C and $FF80;
    end;

    Dest^ := C;
    Inc(Dest);
    Dec(Count);
  end;

  SetLength(Result, (NativeUInt(Dest) - NativeUInt(Result)) div SizeOf(WideChar));
end;
```

### Сравнительное тестирование (общее)

В данном тестировании приняли участие FlexBin и популярная для задач сериализации библиотека Flatbuffers. Возможно, в будущем появится сравнительное тестирование с другими библиотеками. Время записи и чтения указано в миллисекундах на 10 млн. итераций. Система: i5-4670 CPU 3.40 GHz, MS Windows 10, архитектура x64. FlexBin реализован в Delphi.

В тестировании участвует данная структура:
```cpp
struct Foo
{
    // обязательные поля, значения которых 0
    bool               A;    /*id 000*/
    signed char        B;    /*id 001*/
    unsigned char      C;    /*id 002*/
    signed short       D;    /*id 003*/
    unsigned short     E;    /*id 004*/
    signed long        F;    /*id 005*/
    unsigned long      G;    /*id 006*/
    signed long long   H;    /*id 007*/
    unsigned long long I;    /*id 008*/
    float              J;    /*id 009*/
    double             K;    /*id 010*/

    // обязательные поля, значения которых произвольные
    bool               L;    /*id 100*/
    signed char        M;    /*id 101*/
    unsigned char      N;    /*id 102*/
    signed short       O;    /*id 103*/
    unsigned short     P;    /*id 104*/
    signed long        Q;    /*id 105*/
    unsigned long      R;    /*id 106*/
    signed long long   S;    /*id 107*/
    unsigned long long T;    /*id 108*/
    float              U;    /*id 109*/
    double             V;    /*id 110*/

    // опциональные поля, значения которых произвольные
    // но совпадают со значениями по умолчанию
    bool               _L;   /*id 200*/
    signed char        _M;   /*id 201*/
    unsigned char      _N;   /*id 202*/
    signed short       _O;   /*id 203*/
    unsigned short     _P;   /*id 204*/
    signed long        _Q;   /*id 205*/
    unsigned long      _R;   /*id 206*/
    signed long long   _S;   /*id 207*/
    unsigned long long _T;   /*id 208*/
    float              _U;   /*id 209*/
    double             _V;   /*id 210*/

  Foo()
  {
    A = false;
    B = 0;
    C = 0;
    D = 0;
    E = 0;
    F = 0;
    G = 0;
    H = 0;
    I = 0;
    J = 0;
    K = 0;

    L = true;
    M = -5;
    N = 5;
    O = -100;
    P = 100;
    Q = -100500;
    R = 100500;
    S = -200600;
    T = 200600;
    U = 1234.567;
    V = 765.4321;

    _L = true;
    _M = -5;
    _N = 5;
    _O = -100;
    _P = 100;
    _Q = -100500;
    _R = 100500;
    _S = -200600;
    _T = 200600;
    _U = 1234.567;
    _V = 765.4321;
  }
};
```
| Способ   | Время записи (мс. за 10 млн. итераций) | Размер (байт) | Время чтения (мс. за 10 млн. итераций) | Комментарий |
| :---: | :---: | :---: | :---: | :--- |
| FlexBin | 1062 | 73 | 640 | Когда FlexBin работает с опциональными или обязательными полями, размер результирующего бинарного потока чаще всего будет разный, т.к. проводится упаковка полей, т.е. подбор оптимального представления полей в памяти. Поэтому в данном тесте размер минимальный, а время записи максимальное. С другой стороны данный подход обеспечивает очень хорошую скорость чтения, т.к. ряд полей (в данном случае 11) могут совпадать со значением по умолчанию и не писаться в буфер. Предлагаю так же учесть, что данный подход обеспечивает лучшую дружественность к кешу процессора и экономит время загрузки извне, что на дисковых накопителях или сетевых протоколах может дать существенный прирост производительности. |
| FlexBin (все поля упрощённые) | 812 | 193 | 859 | Упрощённые поля лишены рутины поиска оптимального представления в памяти, поэтому пишутся все поля в их базовом представлении, не зависимо от того, совпадает их значение со значением по умолчанию или нет. Данные виды полей позволяют ускорить запись, но результирующий размер может быть существенно больше, и скорость чтения, из-за бо́льшего количества полей, так же может быть ниже. |
| FlexBin (все поля фиксированные) | 218 | 130 | 234 | Фиксированные поля обеспечивают традиционный способ чтения и записи данных, в данном случае нет гибкости, обратной совместимости, пишутся и читаются чистые данные. Результирующий размер меньше, чем в случае упрощённых полей, т.к. не пишется служебная информация. Скорость записи и чтения самая высокая. Отдельно стоит заметить, что скорость может быть ещё выше, т.е. на Delphi-тесте используется класс с выравниванием на 8 байт, и FlexBin-оптимизатору пришлось задействовать 7 операций разного размера вместо одной. |
| FlexBin (все поля фиксированные, идут последовательно) | 187 | 130 | 203 | В данном тесте все поля располагаются последовательно в packed-структуре, поэтому чтение/запись свелись условно говоря к одной операции копирования памяти. |
| FlexBin (обязательные поля фиксированные) | 437 | 87 | 234 | Данный тест повторяет тест Flatbuffers. Когда обязательные поля фиксированные, а остальные пишутся если значение отличается от значения по-умолчанию. |
| Flatbuffers | 431 | 104 | 322 | Flatbuffers является достаточно быстрой и простой библиотекой. Недостаток Flatbuffers - отсутствие требуемой гибкости. Поля - достаточно жёсткие сущности. Их последовательность, тип и параметр опциональности - со временем нельзя менять. Простые типы пишутся сплошным блоком, через операцию копирования. Сложные типы или опциональные поля управляются через специальную таблицу, поэтому операции получения значения или его изменения, накладывают определённую временную сложность. Кроме того Flatbuffers имеет кодогенерирующую архитектуру, что накладывает определённые ограничения на использование одних и тех же классов для разных протоколов обмена. |


### Сравнительное тестирование (вложенные структуры)

В данном тесте участвуют те же поля, что и в предыдущем тесте. Отличие состоит в том, что поля разбиты на структуры, в том числе многоуровневые. Отдельно стоит сказать, что иерархичная организация данных на логическом уровне не означает такую иерархию на уровне сериализации и десериализации. Иначе говоря, бинарно данная структура может быть записана идентично той, что рассматривалась в предыдущем разделе. И скорости чтения/записи, соответственно, могут совпадать.

```cpp
struct Foo
{
    // обязательные поля, значения которых 0
    bool               A;    /*id 000*/
    signed char        B;    /*id 001*/
    unsigned char      C;    /*id 002*/
    struct
    {
        signed short       D;    /*id 003*/
        unsigned short     E;    /*id 004*/
        signed long        F;    /*id 005*/
        unsigned long      G;    /*id 006*/
        signed long long   H;    /*id 007*/
        unsigned long long I;    /*id 008*/
        float              J;    /*id 009*/
        double             K;    /*id 010*/

        // обязательные поля, значения которых произвольные
        struct
        {
            bool               L;    /*id 100*/
            signed char        M;    /*id 101*/
            unsigned char      N;    /*id 102*/
            signed short       O;    /*id 103*/
            unsigned short     P;    /*id 104*/
            signed long        Q;    /*id 105*/
            struct
            {
                unsigned long      R;    /*id 106*/
                signed long long   S;    /*id 107*/
                unsigned long long T;    /*id 108*/
                float              U;    /*id 109*/
                double             V;    /*id 110*/

                // опциональные поля, значения которых произвольные
                // но совпадают со значениями по умолчанию
                struct
                {
                    bool               _L;   /*id 200*/
                    signed char        _M;   /*id 201*/
                    unsigned char      _N;   /*id 202*/
                    signed short       _O;   /*id 203*/
                    unsigned short     _P;   /*id 204*/
                    signed long        _Q;   /*id 205*/
                    struct
                    {
                        unsigned long      _R;   /*id 206*/
                        signed long long   _S;   /*id 207*/
                        unsigned long long _T;   /*id 208*/
                    } S5; /*id 255*/
                } S4; /*id 254*/
            } S3; /*id 253*/
        } S2; /*id 252*/
    } S1; /*id 251*/

    struct
    {
        float              _U;   /*id 209*/
        double             _V;   /*id 210*/
    } S6; /*id 250*/

  Foo()
  {
    A = false;
    B = 0;
    C = 0;
    S1.D = 0;
    S1.E = 0;
    S1.F = 0;
    S1.G = 0;
    S1.H = 0;
    S1.I = 0;
    S1.J = 0;
    S1.K = 0;

    S1.S2.L = true;
    S1.S2.M = -5;
    S1.S2.N = 5;
    S1.S2.O = -100;
    S1.S2.P = 100;
    S1.S2.Q = -100500;
    S1.S2.S3.R = 100500;
    S1.S2.S3.S = -200600;
    S1.S2.S3.T = 200600;
    S1.S2.S3.U = 1234.567;
    S1.S2.S3.V = 765.4321;

    S1.S2.S3.S4._L = true;
    S1.S2.S3.S4._M = -5;
    S1.S2.S3.S4._N = 5;
    S1.S2.S3.S4._O = -100;
    S1.S2.S3.S4._P = 100;
    S1.S2.S3.S4._Q = -100500;
    S1.S2.S3.S4.S5._R = 100500;
    S1.S2.S3.S4.S5._S = -200600;
    S1.S2.S3.S4.S5._T = 200600;
    S6._U = 1234.567;
    S6._V = 765.4321;
  }
};
```

| Способ   | Время записи (мс. за 10 млн. итераций) | Размер (байт) | Время чтения (мс. за 10 млн. итераций) | Комментарий |
| :---: | :---: | :---: | :---: | :--- |
| FlexBin | 1437 | 91 | 1125 | Итоговый размер больше на 18 байт, т.к. появляется служебная информация для 6 структур, по 3 байта на структуру: байт тип, байт идентификатор и байт окончания. Скорость чтения и записи замедляется в 1,5-2 раза, как минимум потому, что полей стало больше: было 33, стало 39. Ну, и с точки зрения организации кода, чтение и запись структур предполагает определённый оверхед. Ещё раз акцентирую внимание на том, что иерархичная организация данных не означает, что вы обязаны использовать иерархию структур в бинарном потоке. Дочерние поля можно писать как обычные поля родительского класса. В этом случае размер и скорость будут совпадать с предыдущим тестом. |
| FlexBin (все структуры опциональные) | 1438 | 82 | 875 | Итоговый размер уменьшился на 9 байт, т.к. 3 структуры в бинарный поток не попали: S4, S5 и S6. Опциональные структуры работают так, что если при их записи ни одно из полей не записано - структура тоже не пишется. |
| FlexBin (все структуры фиксированные) | 250 | 133 | 266 | Фиксированные структуры значат, что все их поля, в том числе иерархично, пишутся сплошным куском бинарных данных. В данном тесте все 6 структур пишутся и читаются за одну операцию копирования памяти. Результат немного отличается от классического, но только потому, что первые три поля (A, B и C) не фиксированные. Если их сделать фиксированными - результаты совпадут. |
